<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Stage Quiz</title>
  <style>
    :root{--accent:#0b71ea;--ok:#0ea55a;--bad:#e04b4b}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:#f7f9fc;color:#17202a}
    .wrap{max-width:980px;margin:18px auto;padding:16px;background:#fff;border-radius:10px;box-shadow:0 6px 20px rgba(18,38,63,0.06)}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{font-size:18px;margin:0}
    .meta{font-size:13px;color:#4b5563}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin:12px 0}
    button{background:var(--accent);border:none;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer}
    button.secondary{background:#f2f4f7;color:#0b1220;border:1px solid #e6e9ef}
    button.ghost{background:transparent;border:1px solid #e6e9ef;color:#0b1220}
    .stageInfo{display:flex;align-items:center;gap:12px}
    .progress{height:10px;background:#eef3fb;border-radius:999px;overflow:hidden;width:220px}
    .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#6aa8ff);width:0%}
    #questions{margin-top:12px}
    .question{padding:12px;border-radius:8px;border:1px solid #eef2f6;margin-bottom:12px}
    .qimage{margin:10px 0;display:block;max-width:100%;height:auto;border-radius:6px;border:1px solid #eef2f6}
    .qtitle{font-weight:600; white-space: pre-wrap;}
    .qtitle pre {background: #f1f5f9; padding: 8px; border-radius: 6px; overflow-x: auto; font-family: monospace; font-size: 13px; margin: 8px 0;}
    .qtitle code {background: #f1f5f9; padding: 2px 4px; border-radius: 4px; font-family: monospace; font-size: 13px;}
    .opts{margin-top:8px;display:flex;flex-direction:column;gap:6px}
    label.opt{display:flex;align-items:flex-start;gap:8px;padding:8px;border-radius:6px;border:1px solid transparent}
    label.opt code {background: #f1f5f9; padding: 2px 4px; border-radius: 4px; font-family: monospace; font-size: 13px;}
    label.opt.correct{background:rgba(14,165,90,0.08);border-color:rgba(14,165,90,0.16)}
    label.opt.incorrect{background:rgba(224,75,75,0.06);border-color:rgba(224,75,75,0.12)}
    .small{font-size:13px;color:#475569}
    footer{display:flex;justify-content:space-between;align-items:center;margin-top:12px}
    @media(max-width:640px){.wrap{margin:8px;padding:12px}.progress{width:140px}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Quiz — Stage-based (10 per stage)</h1>
        <div class="meta">선택 후 "Check"를 눌러 정답을 확인하세요. 저장/불러오기 지원.</div>
      </div>
      <div class="stageInfo">
        <div class="meta">Stage <span id="stageNumber">1</span> / <span id="stageTotal">1</span></div>
        <div class="progress" title="progress"><i id="progressBar"></i></div>
      </div>
    </header>
    <div style="max-width:980px;margin:6px auto 0;padding:0 16px;color:#64748b;font-size:13px">퀴즈 항목: <span id="quizCount">-</span> — 스테이지 수: <span id="stageCount">-</span></div>

    <div class="controls">
      <button id="prevBtn" class="secondary">이전</button>
      <button id="nextBtn" class="secondary">다음</button>
      <button id="checkBtn">Check</button>
      <button id="saveBtn" class="ghost">저장</button>
      <button id="loadBtn" class="ghost">불러오기</button>
      <button id="resetBtn" class="ghost">스테이지 리셋</button>
    </div>

    <div id="questions"></div>

    <footer>
      <div class="small">데이터: <span id="dataStatus">loading…</span></div>
      <div class="small">저장키: <strong>quiz_progress_v1</strong></div>
    </footer>
  </div>

  <script>
  (function(){
    const QUESTIONS_PER_STAGE = 10;
    const STORAGE_KEY = 'quiz_progress_v1';
    const statusEl = document.getElementById('dataStatus');
    const questionsEl = document.getElementById('questions');
    const stageNumberEl = document.getElementById('stageNumber');
    const stageTotalEl = document.getElementById('stageTotal');
    const progressBar = document.getElementById('progressBar');

    let quiz = [];
    let stage = 0;
    let availableImages = [];

    function tryFetchPaths(paths){
      const ts = Date.now();
      return paths.reduce((p, path) => p.catch(()=>fetch(path + '?_=' + ts).then(r=>{ if(!r.ok) throw new Error('no'); return r.json() })), Promise.reject())
    }

    async function loadQuiz(){
      const candidates = ['quiz.json','./quiz.json','/quiz.json','docs/quiz.json','./docs/quiz.json','/docs/quiz.json','../docs/quiz.json'];
      try{
        const data = await tryFetchPaths(candidates);
        quiz = normalize(data);
        // try to load images_list.json to help resolve image filenames
        try{
          const imgs = await tryFetchPaths(['images_list.json','./images_list.json','../images_list.json','/images_list.json']);
          if(Array.isArray(imgs)) availableImages = imgs.map(s=>String(s));
        }catch(e){ availableImages = [] }
        // post-process quiz to resolve image names using availableImages
        try{ quiz = resolveQuizImages(quiz); }catch(e){ /* ignore */ }
        statusEl.textContent = 'loaded (fetch) — ' + quiz.length + ' items';
        // update debug/status counts
        try{ document.getElementById('quizCount').textContent = quiz.length; }catch(e){}
        try{ document.getElementById('stageCount').textContent = Math.max(1, Math.ceil(quiz.length / QUESTIONS_PER_STAGE)); }catch(e){}
        try{ console.log('quiz loaded, length=', quiz.length); }catch(e){}
      }catch(e){
        // fallback to window-provided data
        const w = window.quiz || window.data || window.questions || [];
        if(w && w.length) { quiz = normalize(w); statusEl.textContent = 'loaded (inline)'; }
        else { quiz = []; statusEl.textContent = '데이터가 없습니다. quiz.json 또는 window.quiz 필요'; }
      }
      stage = 0;
      renderStage();
      updateStageInfo();
    }

    function normalize(arr){
      // Ensure array of {question, options:[{text,correct}]}
      if(!Array.isArray(arr)) return [];
      return arr.map(item=>{
        const q = {};
        // prefer explicit fields
        let rawQuestion = item.question || item.q || '';
        // if question contains markdown image like ![alt](path) extract it
        q.image = item.image || item.img || item.image_url || null;
        try{
          const mdImg = rawQuestion.match(/!\[[^\]]*\]\(([^)]+)\)/);
          if(mdImg && !q.image){ q.image = mdImg[1]; rawQuestion = rawQuestion.replace(/!\[[^\]]*\]\(([^)]+)\)/,'').trim(); }
          // also handle inline HTML <img src="...">
          const htmlImg = rawQuestion.match(/<img[^>]*src=["']?([^"' >]+)["']?[^>]*>/i);
          if(!q.image && htmlImg){ q.image = htmlImg[1]; rawQuestion = rawQuestion.replace(/<img[^>]*>/i,'').trim(); }
        }catch(e){ /* ignore */ }
        // normalize image path when serving from /docs/ (images are at ../images/)
        if(q.image && typeof q.image === 'string'){
          // leave absolute or http(s) alone
          if(!/^https?:\/\//i.test(q.image) && !/^\//.test(q.image)){
            // if it references images/ relative to repo root, prepend ../ to reach it from docs/
            q.image = q.image.replace(/^\.\/?images\//i, '../images/');
            if(!/^\.\./.test(q.image) && !/images\//i.test(q.image)){
              q.image = '../' + q.image;
            }
          }
        }
        q.question = rawQuestion;
        const opts = item.options || item.opts || [];
        // if options empty, detect lettered fields (A,B,C,D...) or a choices object
        if((!opts || opts.length===0) && typeof item === 'object'){
          const letters = ['A','B','C','D','E','F'];
          const found = [];
          letters.forEach(l=>{ if(item[l]) found.push({text: String(item[l]), correct: false}); });
          if(found.length) {
            // use found as options
            opts.push(...found);
          } else if(item.choices && typeof item.choices === 'object'){
            // choices may be an object mapping keys to text
            Object.keys(item.choices).forEach(k=> opts.push({text: String(item.choices[k]), correct:false}));
          }
        }
        q.options = opts.map(o=>{
          if(typeof o === 'string') return {text:o, correct:false};
          if(typeof o === 'object'){
            const img = o.image || o.img || o.image_url || null;
            if('text' in o) return {text: (typeof o.text==='object'? JSON.stringify(o.text) : o.text), correct: !!o.correct, image: img};
            const text = o.option || o.label || o.name || JSON.stringify(o);
            return {text, correct: !!(o.correct || o.isCorrect || o.answer), image: img};
          }
          return {text:String(o), correct:false};
        });
        return q;
      });
    }

    function resolveQuizImages(qarr){
      if(!Array.isArray(qarr)) return qarr;
      const files = (availableImages||[]).slice();
      const findMatch = (name)=>{
        if(!name) return null;
        const s = String(name).trim();
        if(/^https?:\/\//i.test(s) || /^\//.test(s)) return s;
        // take basename
        const base = s.split(/[\\\/]/).pop();
        const low = base.toLowerCase().replace(/[^a-z0-9._-]/g,'');
        // exact match
        let m = files.find(f=>f.toLowerCase()===base.toLowerCase());
        if(m) return m.startsWith('..')? m : ('../images/'+m);
        // match by simplified token
        m = files.find(f=>f.toLowerCase().replace(/[^a-z0-9]/g,'').includes(low) || low.includes(f.toLowerCase().replace(/[^a-z0-9]/g,'')));
        if(m) return '../images/'+m;
        // fallback: use provided relative path adjusted for docs
        let candidate = s.replace(/^\.\/?images\//i, '../images/');
        if(!/^\.\./.test(candidate) && !/images\//i.test(candidate)) candidate = '../' + candidate;
        return candidate;
      };
      return qarr.map(q=>{
        try{
          if(q.image) q.image = findMatch(q.image) || q.image;
          if(Array.isArray(q.options)) q.options = q.options.map(o=>{ if(o && o.image){ o.image = findMatch(o.image) || o.image } return o });
        }catch(e){}
        return q;
      })
    }

    function updateStageInfo(){
      const totalStages = Math.max(1, Math.ceil(quiz.length / QUESTIONS_PER_STAGE));
      stageNumberEl.textContent = (stage+1);
      stageTotalEl.textContent = totalStages;
      const pct = totalStages===0?0: Math.round(((stage+1)/totalStages)*100);
      progressBar.style.width = pct + '%';
    }

    function renderStage(){
      questionsEl.innerHTML = '';
      if(!quiz.length){ questionsEl.innerHTML = '<div class="small">퀴즈 데이터가 없습니다.</div>'; return }
      const start = stage * QUESTIONS_PER_STAGE;
      const slice = quiz.slice(start, start + QUESTIONS_PER_STAGE);
      slice.forEach((q, idx)=>{
        const idxGlobal = start + idx;
        const qwrap = document.createElement('div'); qwrap.className='question';
        const title = document.createElement('div'); title.className='qtitle'; 
        // Handle markdown images in question text
        let qText = q.question;
        const imgMatch = qText.match(/!\[[^\]]*\]\(([^)]+)\)/);
        if (imgMatch && !q.image) {
          q.image = imgMatch[1];
          qText = qText.replace(/!\[[^\]]*\]\(([^)]+)\)/, '').trim();
        }
        title.innerHTML = (idxGlobal+1)+'. '+qText; 
        qwrap.appendChild(title);
        // if question has an associated image, render it between title and options
        if(q.image){
          try{
            const img = document.createElement('img'); img.className='qimage'; img.alt = q.question || ('question-'+(idxGlobal+1));
            // prepare candidate srcs to try in order when loading fails
            const orig = String(q.image || '').trim();
            const candidates = [];
            if(orig) candidates.push(orig);
            // strip leading ./ or ../
            const noDot = orig.replace(/^\.\/?/, '').replace(/^\.\./, '');
            if(noDot && !candidates.includes(noDot)) candidates.push(noDot);
            // images/ variants
            if(!/^images\//i.test(orig)) candidates.push('images/' + noDot);
            // docs relative
            if(!/^\.\./.test(orig)) candidates.push('../' + noDot);
            // absolute from server root
            if(!/^\//.test(noDot)) candidates.push('/' + noDot);

            let tryIdx = 0;
            img.onerror = function(){
              tryIdx++;
              if(tryIdx < candidates.length){
                img.src = candidates[tryIdx];
              } else {
                // give up — remove image element
                img.remove();
              }
            };
            // start with first candidate
            img.src = candidates[0] || '';
            qwrap.appendChild(img);
          }catch(e){ /* ignore image render errors */ }
        }
        const opts = document.createElement('div'); opts.className='opts';
        const isMulti = q.options.filter(o=>isCorrect(o)).length>1;
        q.options.forEach((o,i)=>{
          const id = 'q'+idxGlobal+'-o'+i;
          const lab = document.createElement('label'); lab.className='opt'; lab.htmlFor = id;
          const inp = document.createElement('input'); inp.type = isMulti? 'checkbox':'radio'; inp.name = 'q'+idxGlobal; inp.id = id; inp.dataset.idx = i;
          const txt = document.createElement('div'); txt.style.flex='1'; 
          
          let optText = getOptionText(o);
          const optImgMatch = optText.match(/<img src='([^']+)'/);
          if (optImgMatch && !o.image) {
            o.image = optImgMatch[1];
            optText = optText.replace(/<img[^>]+>/, '').trim();
          }
          
          // Handle markdown images in option text
          const mdOptImgMatch = optText.match(/!\[[^\]]*\]\(([^)]+)\)/);
          if (mdOptImgMatch && !o.image) {
            o.image = mdOptImgMatch[1];
            optText = optText.replace(/!\[[^\]]*\]\(([^)]+)\)/, '').trim();
          }
          
          txt.innerHTML = optText; // Use innerHTML to render any remaining HTML tags like <code>
          
          lab.appendChild(inp); lab.appendChild(txt);
          // render option image if present
          if(o && o.image){
            const oi = document.createElement('img'); oi.className = 'qimage'; oi.style.maxHeight='120px'; oi.style.objectFit='contain'; oi.style.marginLeft='8px';
            // normalize option image path similar to question image
            let opImg = String(o.image || '').trim();
            const candidates = [];
            if(opImg) candidates.push(opImg);
            const noDot = opImg.replace(/^\.\/?/, '').replace(/^\.\./, '');
            if(noDot && !candidates.includes(noDot)) candidates.push(noDot);
            if(!/^images\//i.test(opImg)) candidates.push('images/' + noDot);
            if(!/^\.\./.test(opImg)) candidates.push('../' + noDot);
            if(!/^\//.test(noDot)) candidates.push('/' + noDot);

            let tryIdx = 0;
            oi.onerror = function(){
              tryIdx++;
              if(tryIdx < candidates.length){
                oi.src = candidates[tryIdx];
              } else {
                oi.remove();
              }
            };
            oi.src = candidates[0] || '';
            lab.appendChild(oi);
          }
          opts.appendChild(lab);
        });
        qwrap.appendChild(opts);
        questionsEl.appendChild(qwrap);
      });
      // restore saved choices if exist
      loadStageToUI(stage);
    }

    function getOptionText(o){ return (typeof o === 'string')? o : (o && (o.text||o.label||o.option) ) || JSON.stringify(o) }
    function isCorrect(o){ return !!(o && (o.correct===true || o.isCorrect===true || o.answer===true)) }

    function collectAnswersForStage(s){
      const start = s * QUESTIONS_PER_STAGE;
      const answers = {};
      const nodes = questionsEl.querySelectorAll('.question');
      nodes.forEach((qnode, idx)=>{
        const idxGlobal = start + idx;
        const checked = Array.from(qnode.querySelectorAll('input')).filter(i=>i.checked).map(i=>parseInt(i.dataset.idx,10));
        answers[idxGlobal] = checked;
      });
      return answers;
    }

    function saveStage(){
      const answers = collectAnswersForStage(stage);
      const store = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
      store['stage_'+stage] = answers;
      store._lastStage = stage;
      localStorage.setItem(STORAGE_KEY, JSON.stringify(store));
      alert('스테이지 저장됨');
    }

    function loadStageToUI(s){
      const store = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
      const data = store['stage_'+s];
      if(!data) return;
      const start = s * QUESTIONS_PER_STAGE;
      const nodes = questionsEl.querySelectorAll('.question');
      nodes.forEach((qnode, idx)=>{
        const idxGlobal = start + idx;
        const sel = data[idxGlobal] || [];
        qnode.querySelectorAll('input').forEach(inp=>{ inp.checked = sel.includes(parseInt(inp.dataset.idx,10)); inp.disabled = false; inp.parentElement.classList.remove('correct','incorrect'); });
      });
    }

    function loadStage(){
      const store = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
      if(store._lastStage!=null) { stage = store._lastStage; }
      renderStage(); updateStageInfo();
      alert('저장된 스테이지 불러옴');
    }

    function resetStage(){
      if(!confirm('이 스테이지의 저장된 응답을 삭제하시겠습니까?')) return;
      const store = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
      delete store['stage_'+stage];
      localStorage.setItem(STORAGE_KEY, JSON.stringify(store));
      renderStage();
    }

    function checkStage(){
      const start = stage * QUESTIONS_PER_STAGE;
      const nodes = questionsEl.querySelectorAll('.question');
      nodes.forEach((qnode, idx)=>{
        const idxGlobal = start + idx;
        const q = quiz[idxGlobal];
        if(!q) return;
        const inputs = Array.from(qnode.querySelectorAll('input'));
        const selected = inputs.filter(i=>i.checked).map(i=>parseInt(i.dataset.idx,10));
        const correctIdx = q.options.map((o,i)=>isCorrect(o)?i:null).filter(x=>x!==null);
        const ok = selected.length === correctIdx.length && selected.every(v=>correctIdx.includes(v));
        // highlight
        inputs.forEach(i=>{
          const lab = i.parentElement; lab.classList.remove('correct','incorrect');
          const iidx = parseInt(i.dataset.idx,10);
          if(isCorrect(q.options[iidx])) lab.classList.add('correct');
          if(i.checked && !isCorrect(q.options[iidx])) lab.classList.add('incorrect');
          i.disabled = true;
        });
        // append result note
        let note = qnode.querySelector('.result-note');
        if(!note){ note = document.createElement('div'); note.className='result-note small'; note.style.marginTop='8px'; qnode.appendChild(note); }
        note.textContent = ok? '정답입니다.' : '오답입니다.';
      });
    }

    // navigation
    document.getElementById('prevBtn').addEventListener('click', ()=>{ if(stage>0) stage--; renderStage(); updateStageInfo(); });
    document.getElementById('nextBtn').addEventListener('click', ()=>{ const maxStage = Math.max(0, Math.ceil(quiz.length/QUESTIONS_PER_STAGE)-1); if(stage<maxStage) stage++; renderStage(); updateStageInfo(); });
    document.getElementById('checkBtn').addEventListener('click', checkStage);
    document.getElementById('saveBtn').addEventListener('click', saveStage);
    document.getElementById('loadBtn').addEventListener('click', loadStage);
    document.getElementById('resetBtn').addEventListener('click', resetStage);

    // init
    loadQuiz();
    // expose for debugging
    window._quiz_internal = {loadQuiz, renderStage, quiz};
  })();
  </script>
</body>
</html>